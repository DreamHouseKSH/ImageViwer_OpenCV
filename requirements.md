# 대용량 항공사진 이미지 뷰어 개발 요구사항 문서

## 1. 프로젝트 개요

### 1.1 목적
대용량 항공사진을 효율적으로 탐색하고 분석할 수 있는 고성능 이미지 뷰어 개발

### 1.2 주요 기능
- 대용량 항공사진 로드 및 표시
- 고성능 이미지 네비게이션
- 측정 및 분석 도구 제공
- 이미지 처리 기능

## 2. 상세 요구사항

### 2.1 기능 요구사항

#### 2.1.1 기본 뷰어 기능
- [ ] 대용량 이미지 로드 (1GB 이상)
- [ ] 이미지 패닝(이동)
- [ ] 줌 인/아웃 (마우스 휠, 터치 제스처)
- [ ] 회전 및 미러링
- [ ] 멀티탭 지원

#### 2.1.2 성능 최적화
- [ ] 타일 기반 렌더링
- [ ] 이미지 캐싱 시스템
- [ ] 다중 스레드 이미지 처리
- [ ] GPU 가속 렌더링

#### 2.1.3 측정 도구
- [ ] 거리 측정 (픽셀/실제 거리)
- [ ] 영역 측정 (면적 계산)
- [ ] 각도 측정
- [ ] 좌표 표시 (WGS84, UTM 등)

#### 2.1.4 이미지 처리
- [ ] 밝기/대비/감마 조정
- [ ] 히스토그램 평활화
- [ ] 색상 보정
- [ ] 필터 적용 (샤프닝, 블러 등)

### 2.2 비기능 요구사항

#### 2.2.1 성능
- **로딩 성능**:
  - 1GB 이미지: 3초 이내 초기 로드 (SSD 기준)
  - 타일 기반 로딩으로 초기 대기시간 최소화
  
- **렌더링 성능**:
  - 줌/패닝 시 60FPS 이상 유지 (M1 Pro 기준 4K 디스플레이)
  - Metal을 이용한 하드웨어 가속
  - 멀티스레드 렌더링 파이프라인
  
- **메모리 효율성**:
  - 이미지 당 메모리 사용량: 원본 크기의 1.2x 이하
  - 메모리 매핑을 통한 지연 로딩
  - 자동 메모리 관리 (LRU 캐시)
  - 메모리 압축 기술 활용
  
- **에너지 효율**:
  - Apple Silicon의 효율적 코어 활용
  - 백그라운드 작업 시 전력 소비 최적화
  - 자동 화면 주사율 조정 (ProMotion 디스플레이 대응)

#### 2.2.2 사용성
- 직관적인 사용자 인터페이스
- 사용자 정의 가능한 단축키
- 고해상도 디스플레이 지원

#### 2.2.3 호환성
- **macOS**: 11.0+ (M1/M2 최적화)
- Windows 10/11 (x86_64)
- Linux (x86_64, ARM64)
- **이미지 형식**: GeoTIFF, JPEG2000, PNG, JPEG, WebP
- **좌표계**: WGS84, UTM 등 다양한 좌표계 지원

## 3. 기술 스택

### 3.1 핵심 기술 (크로스 플랫폼 & 상용화 고려)

#### 3.1.0 라이선스 정책
- **허용적 오픈소스 라이선스** (상용화 가능):
  - MIT/Apache 2.0: 자유로운 상용화 가능
  - BSD 3-Clause: 상업적 사용 허용
  - LGPL: 동적 링크 시 상용화 가능
- **주의 요망 라이선스**:
  - GPL: 상용 제품에 포함 시 전체 소스 공개 필요
  - AGPL: 네트워크 서비스에도 소스 공개 의무

#### 3.1.1 프로그래밍 언어 및 런타임
  - **프로그래밍 언어**: 
    - Python 3.9+ (MIT/PSF License)
    - C++17 (ISO 표준 라이브러리 사용)
    - CMake (BSD-3-Clause) - 크로스 플랫폼 빌드
  - **이미지 처리**:
    - OpenCV 4.8+ (Apache 2.0)
    - libjpeg-turbo (BSD-3-Clause, IJG, zlib)
    - libtiff (BSD-2-Clause)
    - libpng (libpng License)
    - OpenJPEG (BSD-2-Clause)
    - GDAL (MIT/X11) - 래스터/벡터 포맷 지원

  - **GUI 프레임워크**:
    - Qt 6.5+ (LGPLv3/Commercial)
      - PySide6 (LGPL) - Python 바인딩
      - QtCharts (LGPL)
      - QtGraph (MIT) - 고성능 플로팅
    - 대안: Dear ImGui (MIT) + pyimgui (MIT) - 경량 GUI

- **지리공간 처리**:
  - GDAL 3.7+ (M1/M2 최적화)
  - PROJ (좌표 변환)
  - Rasterio (래스터 데이터 처리)

- **수치 계산**:
  - NumPy (M1/M2 Accelerate 프레임워크 연동)
  - SciPy (과학 계산)
  - Numba (JIT 컴파일 가속)

  - **하드웨어 가속**:
    - OpenGL 4.1+ (크로스 플랫폼)
      - GLFW (MIT/Zlib) - 윈도우/컨텍스트 관리
      - GLAD (MIT) - 로더 생성기
    - Vulkan (Apache 2.0) - 차세대 그래픽스 API
    - Metal (macOS 전용, Apple 라이선스)
    - DirectX 12 (Windows 전용, 상용 라이선스)

### 3.2 개발 도구 (크로스 플랫폼 호환성 보장)

#### 3.2.0 빌드 및 패키징
- **크로스 플랫폼 빌드**:
  - CMake (BSD-3-Clause)
  - Conan (MIT) - C++ 패키지 관리
  - vcpkg (MIT) - C++ 라이브러리 관리

- **패키징**:
  - PyInstaller (GPL-2.0-or-later with exception) - 실행 파일 패키징
  - NSIS (zlib) - Windows 인스톨러
  - create-dmg (MIT) - macOS 디스크 이미지
  - AppImage (GPL-2.0) - Linux 배포용

#### 3.2.1 테스팅 및 품질 관리
- **버전 관리**:
  - Git (LFS 대용량 파일 지원 안함)
  - GitHub/GitLab 호스팅

- **이슈 및 프로젝트 관리**:
  - GitHub Projects (애자일 보드)
  - GitHub Issues (이슈 트래킹)
  - Milestones (릴리즈 계획)

- **CI/CD 파이프라인**:
  - GitHub Actions (M1/M2 러너)
  - 멀티 아키텍처 빌드 (x86_64, arm64)
  - 자동화된 테스트 및 배포
  - Docker 컨테이너화 지원

- **테스팅 프레임워크**:
  - pytest (유닛 테스트)
  - pytest-qt (GUI 테스트)
  - pytest-cov (코드 커버리지)
  - Hypothesis (속성 기반 테스트)

- **빌드 시스템**:
  - CMake 3.25+ (크로스 플랫폼 빌드)
  - Conan (C++ 의존성 관리)
  - cibuildwheel (Python 휠 패키징)

- **종속성 관리**:
  - Poetry (Python 패키지 관리)
  - conda-forge (과학 컴퓨팅 스택)
  - pip-tools (의존성 고정)

- **코드 품질**:
  - pre-commit hooks
  - black (코드 포맷팅)
  - flake8 (린팅)
  - mypy (타입 체킹)
  - SonarQube (정적 분석)

## 4. 시스템 아키텍처 (크로스 플랫폼 고려사항)

### 4.0 플랫폼별 특성 고려
- **Windows**:
  - Direct3D 12/11 폴백 지원
  - High-DPI 디스플레이 대응
  - Windows 10/11 호환성 유지

- **macOS**:
  - Metal 가속 (OpenGL Deprecation 대응)
  - 네이티브 다크 모드 지원
  - 앱 노치/다이내믹 아일랜드 대응

- **Linux**:
  - Wayland/X11 양방향 지원
  - 주요 배포판 호환성 (Ubuntu, Fedora 등)
  - Flatpak/Snap 패키징 지원

### 4.1 아키텍처 개요

### 4.1 아키텍처 개요

#### 4.1.1 플랫폼 최적화
- **M1/M2 최적화**:
  - Metal Performance Shaders 활용
  - Core ML 통합 (이미지 분석 가속)
  - ARM64 네이티브 빌드 (Universal 2 바이너리)
  - 메모리 매핑을 통한 대용량 파일 처리
  - GCD(Grand Central Dispatch)를 이용한 병렬 처리
  - MetalFX 업스케일링 지원
  - 에너지 효율적인 백그라운드 처리
  - Neural Engine 활용 (AI/ML 작업 가속)
  - 메모리 압축 기술 활용
  - SSD I/O 최적화 (APFS 파일 시스템 특성 고려)

#### 4.1.2 컴포넌트 다이어그램
```
+------------------+     +------------------+     +------------------+
|     GUI 레이어    | <-> |   비즈니스 로직   | <-> |   데이터 액세스   |
+------------------+     +------------------+     +------------------+
        ↑                       ↑                        ↑
        |                       |                        |
+------------------+     +------------------+     +------------------+
|  사용자 상호작용  |     |  이미지 처리 엔진  |     |  이미지 파일 시스템  |
+------------------+     +------------------+     +------------------+
```

### 4.2 데이터 흐름
1. 사용자가 이미지 파일 열기 요청
2. 시스템이 이미지 메타데이터 로드 (메타스레딩으로 병렬 처리)
3. 타일 기반으로 이미지 데이터 로드 (Lazy Loading)
4. Metal/GPU 가속을 통한 고성능 렌더링
5. 메모리 풀링을 통한 효율적인 리소스 관리
6. 사용자 인터랙션에 따른 뷰 업데이트 (60 FPS 유지)

## 5. 개발 일정

## 6. 라이선스 호환성 검토

### 6.1 주요 의존성 라이선스
- **Apache 2.0**: OpenCV, TensorFlow Lite
- **MIT**: NumPy, SciPy, Pillow, GLFW, Dear ImGui
- **BSD-3-Clause**: libjpeg-turbo, CMake, Conan
- **LGPL-3.0**: Qt, PySide6
- **GPL-2.0+**: FFmpeg (동적 링크 권장)

### 6.2 상용화 권장사항
1. LGPL 라이브러리(예: Qt)는 동적 링크로 통합
2. GPL 라이브러리는 분리된 프로세스로 실행 (IPC 통신)
3. 모든 오픈소스 라이선스 고지문 포함
4. 소스 코드 배포 의무 사항 준수
5. 타사 라이브러리 라이선스 검증 (FOSSA, FOSSLight 등 활용)

## 7. 개발 일정

### 7.1 1단계: 프로토타입 (3주)
- [ ] 개발 환경 구축 (M1/M2 최적화)
  - Python 환경 설정 (conda/mamba)
  - 의존성 관리 체계 구축
  - CI/CD 파이프라인 설정
  
- [ ] 핵심 엔진 개발
  - Metal/OpenGL 백엔드 구현
  - 타일 기반 이미지 로더
  - 메모리 관리 시스템
  
- [ ] 기본 뷰어 UI 개발
  - PyQt6 기반 메인 윈도우
  - 이미지 표시 컴포넌트
  - 기본 네비게이션 컨트롤
  
- [ ] 성능 프로파일링
  - 메모리 사용량 분석
  - 렌더링 성능 측정
  - 병목 지점 최적화

### 5.2 2단계: 핵심 기능 (4주)
- [ ] 성능 최적화
- [ ] 측정 도구 구현
- [ ] 이미지 처리 기능

### 5.3 3단계: 개선 및 테스트 (2주)
- [ ] 성능 테스트
- [ ] 사용성 개선
- [ ] 버그 수정

## 6. 위험 관리

### 6.1 잠재적 위험
1. 대용량 이미지 처리 성능
   - 완화 전략: 점진적 로딩, 캐싱 전략 적용

2. 크로스 플랫폼 호환성
   - 완화 전략: 표준 라이브러리 사용, 각 플랫폼별 테스트

3. 메모리 관리
   - 완화 전략: 메모리 풀링, 객체 재사용

## 7. 테스트 계획

### 7.1 단위 테스트
- 각 컴포넌트별 독립 테스트
- 이미지 처리 함수 검증

### 7.2 통합 테스트
- 전체 워크플로우 테스트
- 성능 테스트

### 7.3 사용성 테스트
- 실제 사용자 피드백 수집
- UI/UX 개선

## 8. 유지보수 계획

### 8.1 문서화
- API 문서
- 사용자 매뉴얼
- 개발자 가이드

### 8.2 업데이트 정책
- 분기별 기능 업데이트
- 필요시 핫픽스 배포

---
*이 문서는 프로젝트 진행 과정에서 변경될 수 있습니다.*
